trigger:
  - main

pool:
  name: 'azureagent'

variables:
  - group: login-variables 
  - name: IMAGE_NAME
    value: 'my-flask-app'
  - name: IMAGE_TAG
    value: '$(Build.BuildId)'
  - name: PYTHON
    value: '/usr/bin/python3.10'
  - name: ACR_NAME
    value: 'CCSEContainerReg'
  - name: ACR_LOGIN_SERVER
    value: 'ccsecontainerreg.azurecr.io'
  - name: WEBAPP_NAME
    value: 'CCSE2proj'
  - name: RESOURCE_GROUP
    value: 'azurecicd'
  - name: WEBAPP_URL
    value: 'https://ccse2proj-gmfcbpbyh9cmdseb.uksouth-01.azurewebsites.net' 

stages:
  - stage: BuildAndScan
    displayName: 'Build and Security Scan'
    jobs:
      - job: Build
        displayName: 'Build Docker Image and Run Security Scans'
        steps:
          - checkout: self

          - script: |
              $(PYTHON) -m pip install --upgrade pip
              $(PYTHON) -m pip install -r requirements.txt
            displayName: 'Install Python 3.10 Dependencies'
            
          - task: NodeTool@0
            inputs:
              versionSpec: '18.x' 
            displayName: 'Install Node.js and npm'

          # Install jq for JSON parsing
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq
            displayName: 'Install jq for JSON parsing'

          - script: |
              npm install -g snyk
              echo "Authenticating with Snyk..."
              snyk auth $(SNYK_TOKEN)
              
              # Run Snyk Code scan and save results
              echo "Running Snyk Code scan..."
              snyk code test --json > snyk_code_report.json || echo "Snyk code scan completed with findings"
              snyk code test > snyk_code_report.txt || echo "Snyk code scan completed with findings"
              
              # Show what files were created
              echo "Generated files:"
              ls -la *report*
            displayName: 'Run Snyk Code Scan'
            env:
              SNYK_TOKEN: $(SNYK_TOKEN)
            continueOnError: true

          # Security Gate Evaluation
          - script: |
              echo "=== SECURITY GATE EVALUATION ==="
              GATE_FAILED=false
              
              # Function to check Snyk Code JSON reports
              check_snyk_code_report() {
                local file=$1
                local scan_type=$2
                
                if [ -f "$file" ] && [ -s "$file" ]; then
                  echo "Analyzing $scan_type results from $file..."
                  
                  # Check for high severity issues in Snyk Code format
                  HIGH_ISSUES=$(jq '[.runs[]?.results[]? | select(.level == "error")] | length' "$file" 2>/dev/null || echo "0")
                  # Check for medium severity issues (warnings in Snyk Code)
                  MEDIUM_ISSUES=$(jq '[.runs[]?.results[]? | select(.level == "warning")] | length' "$file" 2>/dev/null || echo "0")
                  
                  # Alternative check for different JSON structure
                  if [ "$HIGH_ISSUES" = "0" ] || [ -z "$HIGH_ISSUES" ]; then
                    HIGH_ISSUES=$(jq '[.vulnerabilities[]? | select(.severity == "high")] | length' "$file" 2>/dev/null || echo "0")
                  fi
                  
                  if [ "$MEDIUM_ISSUES" = "0" ] || [ -z "$MEDIUM_ISSUES" ]; then
                    MEDIUM_ISSUES=$(jq '[.vulnerabilities[]? | select(.severity == "medium")] | length' "$file" 2>/dev/null || echo "0")
                  fi
                  
                  echo "$scan_type - High severity issues: $HIGH_ISSUES"
                  echo "$scan_type - Medium severity issues: $MEDIUM_ISSUES"
                  
                  # Fail if ANY high or medium severity issue is found
                  if [ "$HIGH_ISSUES" -gt 0 ] 2>/dev/null; then
                    echo " SECURITY GATE FAILED: $scan_type found $HIGH_ISSUES high severity issue(s)"
                    GATE_FAILED=true
                  fi
                  
                  if [ "$MEDIUM_ISSUES" -gt 0 ] 2>/dev/null; then
                    echo " SECURITY GATE FAILED: $scan_type found $MEDIUM_ISSUES medium severity issue(s)"
                    GATE_FAILED=true
                  fi
                  
                  if [ "$HIGH_ISSUES" -eq 0 ] && [ "$MEDIUM_ISSUES" -eq 0 ]; then
                    echo " $scan_type: No high or medium severity issues found"
                  fi
                else
                  echo "  $scan_type report not found or empty: $file"
                fi
              }
              
              # Check Snyk Code results only
              check_snyk_code_report "snyk_code_report.json" "Snyk Code"
              
              # Alternative: Check text reports if JSON parsing fails
              if [ -f "snyk_code_report.txt" ] && [ -s "snyk_code_report.txt" ]; then
                echo "Checking Snyk Code text report as backup..."
                if grep -i -E "high|medium" "snyk_code_report.txt" > /dev/null; then
                  echo "SECURITY GATE FAILED: Snyk Code found medium/high severity issues in text report"
                  GATE_FAILED=true
                fi
              fi
              
              # Final gate decision
              if [ "$GATE_FAILED" = true ]; then
                echo ""
                echo " SECURITY GATE FAILED: Deployment blocked due to code security vulnerabilities"
                echo "Please fix the identified security issues in your source code before proceeding with deployment."
                exit 1
              else
                echo ""
                echo "SECURITY GATE PASSED: No blocking code security issues found"
                echo "Proceeding with build and deployment..."
              fi
            displayName: 'Security Gate Evaluation - Code Analysis Only'
            env:
              SNYK_TOKEN: $(SNYK_TOKEN)

          - script: |
              docker build -t $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG) .
            displayName: 'Build Docker Image'
            condition: succeeded() # Only build if security gate passed

          # Publish security reports as artifacts
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Security Scan Reports'
            inputs:
              targetPath: '$(System.DefaultWorkingDirectory)'
              artifactName: 'SecurityReports'
              artifactType: 'pipeline'
            condition: always()
            continueOnError: true

  - stage: PushDeploy
    displayName: 'Push and Deploy'
    dependsOn: BuildAndScan
    condition: succeeded() # Only run if BuildAndScan stage (including security gate) succeeded
    jobs:
      - job: Push
        displayName: 'Push Docker Image to ACR'
        steps:
          - checkout: self 
          
          - script: |
              # Rebuild the image since it's a new job
              docker build -t $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG) .
              echo $(ACR_PASSWORD) | docker login $(ACR_LOGIN_SERVER) --username $(ACR_USERNAME) --password-stdin
              docker push $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG)
            displayName: 'Build and Push Docker Image'
            env:
              ACR_USERNAME: $(ACR_USERNAME)
              ACR_PASSWORD: $(ACR_PASSWORD)

      - job: Deploy
        displayName: 'Deploy Docker Image to Azure Web App'
        dependsOn: Push
        steps:
          - script: |
              az webapp config container set \
                --name $(WEBAPP_NAME) \
                --resource-group $(RESOURCE_GROUP) \
                --docker-custom-image-name $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG) \
                --docker-registry-server-url https://$(ACR_LOGIN_SERVER) \
                --docker-registry-server-user $(ACR_USERNAME) \
                --docker-registry-server-password $(ACR_PASSWORD)
              
              echo "Deployment configured. Waiting for service to update and become available..."
              sleep 180 #Waits for 3 mins, gives time for app service to pull image and restart
            displayName: 'Configure Azure Web App and Wait'
            env:
              ACR_USERNAME: $(ACR_USERNAME)
              ACR_PASSWORD: $(ACR_PASSWORD)

      - job: ZapScan
        displayName: 'Run OWASP ZAP Scan'
        dependsOn: Deploy
        condition: succeeded() # Runs if deploy was successful
        steps:
          - script: |
              echo "Waiting for web app to be ready after deployment..."
              sleep 180 # Wait for 3 minutes (adjust as necessary for your app's startup time)
            displayName: 'Wait for Web App to Stabilize'

          - script: |
              echo "Pulling latest ZAP Docker image..."
              # Updated to use the correct image name
              docker pull zaproxy/zap-stable
            displayName: 'Pull ZAP Docker Image'
            continueOnError: true 

          - script: |
              echo "Creating directory for ZAP reports..."
              # Create directory for reports if it doesn't exist
              mkdir -p $(Pipeline.Workspace)/zap_reports 
              echo "Directory created at: $(Pipeline.Workspace)/zap_reports"
            displayName: 'Create ZAP Reports Directory'

          - script: |
              echo "Starting OWASP ZAP baseline scan against $(WEBAPP_URL)..."

              docker run --rm \
                -v $(Pipeline.Workspace)/zap_reports:/zap/wrk/:rw \
                -t zaproxy/zap-stable zap-baseline.py \
                -t $(WEBAPP_URL) \
                -r report.html \
                -x report.xml \
                -J report.json \
                || echo "ZAP scan completed. Warnings or failures may be present in the report. Exit code $?"
            displayName: 'Execute ZAP Baseline Scan'
            continueOnError: true # Allow pipeline to continue so reports can be published

          - script: |
              echo "Checking if ZAP reports directory exists and contains files..."
              ls -la $(Pipeline.Workspace)/zap_reports/ || echo "Reports directory is empty or doesn't exist"
            displayName: 'Verify ZAP Reports'
            continueOnError: true

          - task: PublishPipelineArtifact@1
            displayName: 'Publish ZAP Scan Reports'
            inputs:
              targetPath: '$(Pipeline.Workspace)/zap_reports'
              artifactName: 'ZAPScanResults'
            condition: succeededOrFailed() # Publish reports even if ZAP scan had issues
            continueOnError: true
